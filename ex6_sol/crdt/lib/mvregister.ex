defmodule MVReg do
    use GenServer

    @moduledoc """
    An implementation of a Multi-Value Register (MVReg) CRDT using a GenServer.

    A Multi-Value Register allows for concurrent writes to result in multiple
    values being stored, rather than a single value overwriting others. Conflicts
    are resolved by taking the union of concurrently written values. The register
    maintains a set of (vector clock, value) pairs.

    Note: This implementation uses `GenServer` for state management and does not directly
    implement the `ConflictFreeReplicatedDataType` behaviour as defined in the project.
    Integration with the broader Minidote CRDT framework would require adapting this
    module to conform to that behaviour.
    """

    @type t :: {map(), list()} # {vector_clock, values_with_clocks}
    @type value :: any()
    @type update_message :: {map(), any()} # {update_clock, value}

    @doc """
    Creates a new `MVReg` with a default initial value of `:inital_value`.

    ## Returns
      - `{:ok, pid, any()}`: A tuple containing the PID of the new GenServer process
                             and its initial application view.
    """
    @spec new() :: {:ok, pid(), any()}
    def new() do
        new(:inital_value)
    end

    @doc """
    Creates a new `MVReg` with a specified initial value.

    ## Parameters
      - `initial_value`: The initial value for the register.

    ## Returns
      - `{:ok, pid, any()}`: A tuple containing the PID of the new GenServer process
                             and its initial application view.
    """
    @spec new(any()) :: {:ok, pid(), any()}
    def new(initial_value) do
        {:ok, pid} = GenServer.start(__MODULE__, initial_value)
        app_view = initial_value
        {pid, app_view}
    end

    @doc """
    Sets the value of the `MVReg`.

    This function sends a `{:set, value}` message to the GenServer, which
    updates the register's value and associated vector clock.

    ## Parameters
      - `pid`: The PID of the `MVReg` GenServer.
      - `value`: The new value to set.

    ## Returns
      - `update_message()`: The update message generated by the GenServer.
    """
    @spec set(pid(), value()) :: update_message()
    def set(pid, value) do
        update = GenServer.call(pid, {:set, value})
    end

    @doc """
    Applies an update to the `MVReg`.

    This function sends an `{:update, update}` message to the GenServer.
    It is used to propagate changes within the CRDT.

    ## Parameters
      - `pid`: The PID of the `MVReg` GenServer.
      - `update`: The update message, typically `{:update_clock, value}`.

    ## Returns
      - `list()`: The current application view of the register (a list of values).
    """
    @spec update(pid(), update_message()) :: list()
    def update(pid, update) do
        update = GenServer.call(pid, {:update, update})
    end

    @impl true
    @doc """
    Initializes the `MVReg` GenServer.

    Initializes the register with the `initial_value` and a new vector clock.
    The `initial_value` is stored along with its clock.

    ## Parameters
      - `initial_value`: The initial value for the register.

    ## Returns
      - `{:ok, state}`: The initial state of the GenServer, a tuple `{clock, values}`.
    """
    @spec init(any()) :: {:ok, {map(), list()}}
    def init(initial_value) do
        clock = Vectorclock.increment(Vectorclock.new(), self())
        values = [{clock, initial_value}]
        {:ok, {clock, values}}
    end

    @impl true
    @doc """
    Handles the `{:set, value}` call to set a new value.

    Increments the local vector clock, creates an update message with the new
    clock and value, and replies with this update.

    ## Parameters
      - `{:set, value}`: The call message.
      - `from`: The caller's `GenServer.from()` tuple.
      - `state`: The current state of the GenServer.

    ## Returns
      - `{:reply, update, state}`: A reply containing the update message and the unchanged state.
    """
    @spec handle_call({:set, value()}, GenServer.from(), {map(), list()}) ::
                      {:reply, update_message(), {map(), list()}}
    def handle_call({:set, value}, from, state = {clock, values}) do
        new_clock = Vectorclock.increment(clock, self())
        update = {new_clock, value}
        {:reply, update, state}
    end

    @impl true
    @doc """
    Handles the `{:update, {update_clock, value}}` call to apply an update.

    This clause handles incoming updates. If the `update_clock` is already
    included in the current state's `clock`, the update is ignored. Otherwise,
    the values that are causally preceded by the `update_clock` are removed,
    and the new `value` with its `update_clock` is added. The clocks are then merged.

    ## Parameters
      - `{:update, {update_clock, value}}`: The call message.
      - `from`: The caller's `GenServer.from()` tuple.
      - `state`: The current state of the GenServer.

    ## Returns
      - `{:reply, app_view, new_state}`: A reply containing the updated application view and new state.
    """
    @spec handle_call({update_message()}, GenServer.from(), {map(), list()}) ::
                      {:reply, list(), {map(), list()}}
    def handle_call({update_clock, value}, from, state = {clock, values}) do
        # is the update is already included?
        if Vectorclock.leq(update_clock, clock) do
            app_view = Enum.map(values, fn {c,v} -> v end)
            {:reply, app_view, state}
        else
            # Clear overwritten values
            new_clock = Vectorclock.merge(clock, update_clock)
            partial_values = Enum.reject(values, fn {c, v} -> Vectorclock.leq(c, update_clock) end)
            new_values = [{update_clock, value} | partial_values]
            app_view = Enum.map(new_values, fn {c,v} -> v end)
            {:reply, app_view, {new_clock, new_values}}
        end
    end

    @impl true
    @doc """
    Handles a second clause for `{:update, {update_clock, value}}` call.

    This clause seems to be a duplicate or incomplete. It currently does nothing.
    """
    @spec handle_call({update_message()}, GenServer.from(), {map(), list()}) :: any()
    def handle_call({update_clock, value}, from, {clock, values}) do
    end

    @impl true
    @doc """
    Handles any unexpected `GenServer.call` messages.

    ## Parameters
      - `info`: The unexpected call message.
      - `from`: The caller's `GenServer.from()` tuple.
      - `state`: The current state of the GenServer.

    ## Returns
      - `{:reply, :unexpected_input, state}`: A reply indicating an unexpected input and the unchanged state.
    """
    @spec handle_call(any(), GenServer.from(), {map(), list()}) ::
                      {:reply, :unexpected_input, {map(), list()}}
    def handle_call(info, from, state) do
        IO.inspect("Unexpected call:")
        IO.inspect(info)
        {:reply, :unexpected_input, state}
    end
end
